TRUE * 1
FALSE * 1
knitr::opts_chunk$set(echo = TRUE)
observations <- f + rnorm(length(x), mean = 0, sd = 15)
set.seed(123)
library(ggplot2)
true_relationship <- function(x) { return(6*xˆ3 + 6*xˆ2 - 12*x) }
x <- seq(-3, 2, by = 0.1)
f <- true_relationship(x)
true_relationship <- function(x) { return(6*xˆ3 + 6*xˆ2 - 12*x) }
#set.seed(123)
library(ggplot2)
true_relationship <- function(x) { return(6*xˆ3 + 6*xˆ2 - 12*x) }
x <- seq(-3, 2, by = 0.1)
f <- true_relationship(x)
View(true_relationship)
set.seed(123)
library(ggplot2)
true_relationship <- function(x) {
return(6*x^3 + 6*x^2 - 12*x)
}
x <- seq(-3, 2, by = 0.1)
f <- true_relationship(x)
ggplot() + geom_line(aes(x = x, y = f), color = "black")
knitr::opts_chunk$set(echo = TRUE)
observations <- f + rnorm(length(x), mean = 0, sd = 15)
model1 <- lm(observations ~ poly(x, 1))
predictions1 <- predict(model1, newdata = data.frame(x = x))
model25 <- lm(observations ~ poly(x, 25))
predictions25 <- predict(model25, newdata = data.frame(x = x))
data <- data.frame(x = x,
f = f,
observations = observations,
lm = predictions1,
pm = predictions25)
ggplot(data, aes(x = x)) +
geom_line(aes(y = f), color = "black") +
geom_point(aes(y = observations), color = "blue", shape = 1) +
geom_line(aes(y = lm), color = "red", linetype = "solid") +
geom_line(aes(y = pm), color = "orange", linetype = "solid") +
geom_point(aes(x = 1, y = data[x == 1, "lm"]), color = "red", shape=2) +
geom_point(aes(x = 1, y = data[x == 1, "pm"]), color = "orange", shape=2)
observations_new <- f + rnorm(length(x), mean = 0, sd = 15)
model1 <- lm(observations_new ~ poly(x, 1))
predictions1 <- predict(model1, newdata = data.frame(x = x))
model25 <- lm(observations_new ~ poly(x, 25))
predictions25 <- predict(model25, newdata = data.frame(x = x))
data <- data.frame(x = x,
f = f,
observations = observations_new,
lm = predictions1,
pm = predictions25)
ggplot(data, aes(x = x)) +
geom_line(aes(y = f), color = "black") +
geom_point(aes(y = observations_new), color = "blue", shape = 1) +
geom_line(aes(y = lm), color = "red", linetype = "solid") +
geom_line(aes(y = pm), color = "orange", linetype = "solid") +
geom_point(aes(x = 1, y = data[x == 1, "lm"]), color = "red", shape=2) +
geom_point(aes(x = 1, y = data[x == 1, "pm"]), color = "orange", shape=2)
results1 <- data.frame(x = 1, f_pred = 0)
for (i in 1:500) {
x <- seq(-3, 2, by = 0.1)
f <- true_relationship(x)
temp_observations <- f + rnorm(length(x), mean=0, sd=15)
model1 <- lm(temp_observations ~ poly(x, 1))
results1[i, 1] <- 1
results1[i, 2] <- predict(model1, newdata = data.frame(x=1))
}
ggplot() +
geom_line(data = data, aes(x = x, y = f), color = "black") +
geom_point(data = results1, aes(x = x, y = f_pred), color="red", shape=2)
results20 <- data.frame(x = 1, f_pred = 0)
for (i in 1:500) {
x <- seq(-3, 2, by = 0.1)
f <- true_relationship(x)
temp_observations <- f + rnorm(length(x), mean=0, sd=15)
model20 <- lm(temp_observations ~ poly(x, 20))
results20[i, 1] <- 1
results20[i, 2] <- predict(model20, newdata = data.frame(x=1))
}
ggplot() +
geom_line(data = data, aes(x = x, y = f), color = "black") +
geom_point(data = results20, aes(x = x, y = f_pred), color="orange", shape=2)
models <- vector("list", 25)
for (degree in 1:25) {
model <- lm(observations ~ poly(x, degree))
models[[degree]] <- model
}
results <- data.frame(degree = 1:25, rmse = 0)
for (degree in 1:25) {
predictions <- predict(models[[degree]], newdata = data.frame(x=x))
results[results$degree==degree, "rmse"] <-
sqrt((1/length(predictions))*sum((predictions-observations)ˆ2))
knitr::opts_chunk$set(echo = TRUE)
models <- vector("list", 25)
for (degree in 1:25) {
model <- lm(observations ~ poly(x, degree))
models[[degree]] <- model
}
results <- data.frame(degree = 1:25, rmse = 0)
for (degree in 1:25) {
predictions <- predict(models[[degree]], newdata = data.frame(x=x))
results[results$degree==degree, "rmse"] <-
sqrt((1/length(predictions))*sum((predictions-observations)^2))
}
ggplot() +
geom_line(data = results, aes(x = degree, y = rmse), color = "black")
results <- data.frame(degree = 1:25, rmse = 0)
for (degree in 1:25) {
predictions <- predict(models[[degree]], newdata = data.frame(x=x))
results[results$degree==degree, "rmse"] <-
sqrt((1/length(predictions))*sum((predictions-observations_new)^2))
}
ggplot() +
geom_line(data = results, aes(x = degree, y = rmse), color = "black")
View(results20)
View(models)
knitr::opts_chunk$set(echo = TRUE)
model <- lm(observations ~ poly(x, 4))
predictions=predict(model, newdata = data.frame(x=x))
data = data.frame(x=x, f=f, predictions=predictions)
ggplot(data, aes(x=x)) +
geom_line(aes(y = f), color = "black") +
geom_line(aes(y = predictions), color = "red", linetype="solid")
library(keras)
library(reticulate)
library(tensorflow)
tensorflow::tf_config()
use_virtualenv("my_tf_workspace")
library(keras)
library(reticulate)
library(tensorflow)
use_virtualenv("my_tf_workspace")
tensorflow::tf_config()
setwd("C:/Users/janna/Documents/Merrimack MSDS/DSE6211/Final Project")
library(dplyr)
library(lubridate)
library(caret)
project_data <- read.csv("project_data/project_data.csv")
rownames(project_data) <- project_data$Booking_ID
project_data <- project_data[, -1]
training_ind <- createDataPartition(project_data$booking_status,
p = 0.75,
list = F,
times = 1)
training_set <- project_data[training_ind, ]
test_set <- project_data[-training_ind, ]
training_set$booking_status <- ifelse(training_set$booking_status=="canceled",1,0)
test_set$booking_status <- ifelse(test_set$booking_status=="canceled",1,0)
###### Training Set Categorical Features
top_8_previous_not_cancelled <- training_set %>%
group_by(no_of_previous_bookings_not_canceled) %>%
summarise(count = n()) %>%
arrange(desc(count)) %>%
select(no_of_previous_bookings_not_canceled) %>%
slice(1:8)
top_2_number_of_children <- training_set %>%
group_by(no_of_children) %>%
summarise(count = n()) %>%
arrange(desc(count)) %>%
slice(1:2)
top_3_previous_cancellations <- training_set %>%
group_by(no_of_previous_cancellations) %>%
summarise(count = n()) %>%
arrange(desc(count)) %>%
slice(1:3)
top_8_week_nights <- training_set %>%
group_by(no_of_week_nights) %>%
summarise(count = n()) %>%
arrange(desc(count)) %>%
slice(1:8)
top_6_weekend_nights <- training_set %>%
group_by(no_of_weekend_nights) %>%
summarise(count = n()) %>%
arrange(desc(count)) %>%
slice(1:6)
training_set$no_of_previous_bookings_not_canceled <- ifelse(
training_set$no_of_previous_bookings_not_canceled %in% top_8_previous_not_cancelled$no_of_previous_bookings_not_canceled,
training_set$no_of_previous_bookings_not_canceled, "8+"
)
training_set$no_of_children <- ifelse(
training_set$no_of_children %in% top_2_number_of_children$no_of_children,
training_set$no_of_children, "3+"
)
training_set$no_of_previous_cancellations <- ifelse(
training_set$no_of_previous_cancellations %in% top_3_previous_cancellations$no_of_previous_cancellations,
training_set$no_of_previous_cancellations, "3+"
)
training_set$no_of_week_nights <- ifelse(
training_set$no_of_week_nights %in% top_8_week_nights$no_of_week_nights,
training_set$no_of_week_nights, "8+"
)
training_set$no_of_weekend_nights <- ifelse(
training_set$no_of_weekend_nights %in% top_6_weekend_nights$no_of_weekend_nights,
training_set$no_of_weekend_nights, "6+"
)
training_set$type_of_meal_plan <- ifelse(training_set$type_of_meal_plan %in% c("meal_plan_1", "meal_plan_2"),
training_set$type_of_meal_plan,
"other")
training_set$arrival_date <- parse_date_time(training_set$arrival_date, "ymd")
training_set$booking_date <- int_start(interval(training_set$arrival_date - ddays(training_set$lead_time),
training_set$arrival_date))
season_months <- data.frame(winter = c(12,1,2), spring = c(3,4,5),
summer = c(6,7,8), fall = c(9,10,11))
get_season <- function(x) {
y <- month(x)
# print(y)
for (j in 1:length(colnames(season_months))) {
# print(j)
if (y %in% season_months[[j]]) {
# print(colnames(season_months)[j])
return(colnames(season_months)[j])
}
}
}
training_set$arrival_season <- sapply(training_set$arrival_date, get_season)
training_set$arrival_day <- wday(training_set$arrival_date)
training_set$arrival_day <- ifelse(training_set$arrival_day %in% c(1,6,7),
"weekend", "weekday")
categorical_var <- c(1:7,10:13,15,18,19)
for (i in categorical_var) {
training_set[[i]] <- factor(training_set[[i]])
}
cat_col <- colnames(training_set[, c(1:7,10:13,15,18,19)])
onehot_encoder <- dummyVars(~ no_of_adults + no_of_children + no_of_weekend_nights
+ no_of_week_nights + type_of_meal_plan + required_car_parking_space
+ room_type_reserved + market_segment_type + repeated_guest
+ no_of_previous_cancellations + no_of_previous_bookings_not_canceled
+ no_of_special_requests + arrival_season + arrival_day,
training_set[, c("no_of_adults","no_of_children","no_of_weekend_nights",
"no_of_week_nights","type_of_meal_plan",
"required_car_parking_space",
"room_type_reserved","market_segment_type",
"repeated_guest","no_of_previous_cancellations",
"no_of_previous_bookings_not_canceled",
"no_of_special_requests","arrival_season",
"arrival_day")],
levelsOnly = F,
fullRank = T)
onehot_enc_training <- predict(onehot_encoder, training_set[, c("no_of_adults","no_of_children","no_of_weekend_nights",
"no_of_week_nights","type_of_meal_plan",
"required_car_parking_space",
"room_type_reserved","market_segment_type",
"repeated_guest","no_of_previous_cancellations",
"no_of_previous_bookings_not_canceled",
"no_of_special_requests","arrival_season",
"arrival_day")])
training_set <- cbind(training_set, onehot_enc_training)
####### Test Set Categorical Variables
test_set$no_of_previous_bookings_not_canceled <- ifelse(
test_set$no_of_previous_bookings_not_canceled %in% top_8_previous_not_cancelled$no_of_previous_bookings_not_canceled,
test_set$no_of_previous_bookings_not_canceled, "8+"
)
test_set$no_of_children <- ifelse(
test_set$no_of_children %in% top_2_number_of_children$no_of_children,
test_set$no_of_children, "3+"
)
test_set$no_of_previous_cancellations <- ifelse(
test_set$no_of_previous_cancellations %in% top_3_previous_cancellations$no_of_previous_cancellations,
test_set$no_of_previous_cancellations, "3+"
)
test_set$no_of_week_nights <- ifelse(
test_set$no_of_week_nights %in% top_8_week_nights$no_of_week_nights,
test_set$no_of_week_nights, "8+"
)
test_set$no_of_weekend_nights <- ifelse(
test_set$no_of_weekend_nights %in% top_6_weekend_nights$no_of_weekend_nights,
test_set$no_of_weekend_nights, "6+"
)
test_set$type_of_meal_plan <- ifelse(test_set$type_of_meal_plan %in% c("meal_plan_1", "meal_plan_2"),
test_set$type_of_meal_plan,
"other")
test_set$arrival_date <- parse_date_time(test_set$arrival_date, "ymd")
test_set$booking_date <- int_start(interval(test_set$arrival_date - ddays(test_set$lead_time),
test_set$arrival_date))
test_set$arrival_season <- sapply(test_set$arrival_date, get_season)
test_set$arrival_day <- wday(test_set$arrival_date)
test_set$arrival_day <- ifelse(test_set$arrival_day %in% c(1,6,7),
"weekend", "weekday")
categorical_var <- c(1:7,10:13,15,18,19)
for (i in categorical_var) {
test_set[[i]] <- factor(test_set[[i]])
}
cat_col <- colnames(test_set[, c(1:7,10:13,15,18,19)])
onehot_encoder <- dummyVars(~ no_of_adults + no_of_children + no_of_weekend_nights
+ no_of_week_nights + type_of_meal_plan + required_car_parking_space
+ room_type_reserved + market_segment_type + repeated_guest
+ no_of_previous_cancellations + no_of_previous_bookings_not_canceled
+ no_of_special_requests + arrival_season + arrival_day,
test_set[, c("no_of_adults","no_of_children","no_of_weekend_nights",
"no_of_week_nights","type_of_meal_plan",
"required_car_parking_space",
"room_type_reserved","market_segment_type",
"repeated_guest","no_of_previous_cancellations",
"no_of_previous_bookings_not_canceled",
"no_of_special_requests","arrival_season",
"arrival_day")],
levelsOnly = F,
fullRank = T)
onehot_enc_test <- predict(onehot_encoder, test_set[, c("no_of_adults","no_of_children","no_of_weekend_nights",
"no_of_week_nights","type_of_meal_plan",
"required_car_parking_space",
"room_type_reserved","market_segment_type",
"repeated_guest","no_of_previous_cancellations",
"no_of_previous_bookings_not_canceled",
"no_of_special_requests","arrival_season",
"arrival_day")])
test_set <- cbind(test_set, onehot_enc_test)
##### Numerical Features
test_set[, c("lead_time", "avg_price_per_room")] <- scale(test_set[, c("lead_time", "avg_price_per_room")],
center = apply(training_set[, c("lead_time", "avg_price_per_room")], 2, mean),
scale = apply(training_set[, c("lead_time", "avg_price_per_room")], 2, sd))
training_set[, c("lead_time", "avg_price_per_room")] <- scale(training_set[, c("lead_time", "avg_price_per_room")])
##### Create tensors
train_col <- ncol(training_set)
test_col <- ncol(test_set)
training_features <- array(data = unlist(training_set[, c(8,14,20:train_col)]),
dim = c(nrow(training_set), length(c(8,14,20:train_col))))
training_labels <- array(data = unlist(training_set[, "booking_status"]),
dim = nrow(training_set))
test_features <- array(data = unlist(test_set[, c(8,14,20:test_col)]),
dim = c(nrow(test_set), length(c(8,14,20:test_col))))
test_labels <- array(data = unlist(test_set[, "booking_status"]),
dim = nrow(test_set))
library(reticulate)
library(tensorflow)
library(keras)
use_virtualenv("my_tf_workspace")
# First model
model <- keras_model_sequential(list(
layer_dense(units = 75, activation = "relu"),
layer_dense(units = 37, activation = "relu"),
layer_dense(units = 1, activation = "sigmoid")
))
compile(model,
optimizer = "rmsprop",
loss = "binary_crossentropy",
metrics = "accuracy")
history <- fit(model, training_features, training_labels,
epochs = 100, batch_size = 512, validation_split = 0.33)
plot(history)
# First model
model <- keras_model_sequential(list(
layer_dense(units = 100, activation = "relu"),
layer_dense(units = 50, activation = "relu"),
layer_dense(units = 1, activation = "sigmoid")
))
compile(model,
optimizer = "rmsprop",
loss = "binary_crossentropy",
metrics = "accuracy")
history <- fit(model, training_features, training_labels,
epochs = 100, batch_size = 512, validation_split = 0.33)
plot(history)
# First model
model <- keras_model_sequential(list(
layer_dense(units = 100, activation = "relu"),
layer_dense(units = 100, activation = "relu"),
layer_dense(units = 50, activation = "relu"),
layer_dense(units = 1, activation = "sigmoid")
))
compile(model,
optimizer = "rmsprop",
loss = "binary_crossentropy",
metrics = "accuracy")
history <- fit(model, training_features, training_labels,
epochs = 100, batch_size = 512, validation_split = 0.33)
plot(history)
# First model
model <- keras_model_sequential(list(
layer_dense(units = 100, activation = "relu"),
layer_dense(units = 100, activation = "relu"),
layer_dense(units = 50, activation = "relu"),
layer_dense(units = 1, activation = "sigmoid")
))
compile(model,
optimizer = "rmsprop",
loss = "binary_crossentropy",
metrics = "accuracy")
history <- fit(model, training_features, training_labels,
epochs = 200, batch_size = 512, validation_split = 0.33)
plot(history)
# First model
model <- keras_model_sequential(list(
layer_dense(units = 75, activation = "relu"),
layer_dense(units = 75, activation = "relu"),
layer_dense(units = 37, activation = "relu"),
layer_dense(units = 1, activation = "sigmoid")
))
compile(model,
optimizer = "rmsprop",
loss = "binary_crossentropy",
metrics = "accuracy")
history <- fit(model, training_features, training_labels,
epochs = 100, batch_size = 512, validation_split = 0.33)
plot(history)
# First model
model <- keras_model_sequential(list(
layer_dense(units = 75, activation = "relu"),
layer_dense(units = 37, activation = "relu"),
layer_dense(units = 1, activation = "sigmoid")
))
compile(model,
optimizer = "rmsprop",
loss = "binary_crossentropy",
metrics = "accuracy")
history <- fit(model, training_features, training_labels,
epochs = 100, batch_size = 512, validation_split = 0.33)
plot(history)
# First model
model <- keras_model_sequential(list(
layer_dense(units = 75, activation = "relu"),
layer_dense(units = 37, activation = "relu"),
layer_dense(units = 1, activation = "sigmoid")
))
compile(model,
optimizer = "rmsprop",
loss = "binary_crossentropy",
metrics = "accuracy")
history <- fit(model, training_features, training_labels,
epochs = 100, batch_size = 512, validation_split = 0.33,
callbacks = list(callback_early_stopping(patience = 2)))
plot(history)
# First model
model <- keras_model_sequential(list(
layer_dense(units = 75, activation = "relu"),
layer_batch_normalization(),
layer_dense(units = 37, activation = "relu"),
layer_batch_normalization(),
layer_dense(units = 1, activation = "sigmoid")
))
compile(model,
optimizer = "rmsprop",
loss = "binary_crossentropy",
metrics = "accuracy")
history <- fit(model, training_features, training_labels,
epochs = 100, batch_size = 512, validation_split = 0.33,
callbacks = list(callback_early_stopping(patience = 2)))
plot(history)
